---
title: 'Architecture'
description: 'Understanding Untrace\'s system design and data flow for LLM observability'
---

## System Overview

Untrace consists of several key components working together to provide seamless LLM observability:

<div style={{ display: 'flex', justifyContent: 'center', width: '100%' }}>
  <img src="/images/arch.png" alt="Untrace Architecture" />
</div>

## Data Flow Steps

<Steps>
  <Step title="Trace Capture">
    - SDK captures LLM traces from your applications
    - Traces include model calls, token usage, costs, and metadata
    - Data is sent to Untrace API for processing
  </Step>
  <Step title="Intelligent Routing">
    - Routing engine evaluates traces against configured rules
    - Traces are routed to appropriate observability platforms
    - Multiple destinations can receive the same trace
  </Step>
  <Step title="Platform Delivery">
    - Traces are delivered to LangSmith, Langfuse, and other platforms
    - Real-time monitoring and analytics are available
    - Results are visible in the Untrace dashboard
  </Step>
</Steps>

## Database Schema

### Core Entities

#### Users and Organizations

#### Traces and Integrations

### Key Tables

#### Users
```typescript
interface User {
  id: string;
  email: string;
  firstName?: string;
  lastName?: string;
  online: boolean;
  lastLoggedInAt?: Date;
}
```

#### Organizations
```typescript
interface Org {
  id: string;
  createdByUserId: string;
  name: string;
  plan: 'free' | 'pro' | 'enterprise';
}
```

#### Traces
```typescript
interface Trace {
  id: string;
  userId: string;
  orgId: string;
  model: string;
  provider: string;
  operation: 'chat' | 'completion' | 'embedding';
  input: TraceInput;
  output: TraceOutput;
  metrics: TraceMetrics;
  metadata: Record<string, any>;
  status: 'success' | 'error' | 'timeout';
  timestamp: Date;
}
```

#### Integrations
```typescript
interface Integration {
  id: string;
  orgId: string;
  platform: 'langsmith' | 'langfuse' | 'keywords' | 'webhook';
  config: IntegrationConfig;
  status: 'active' | 'inactive' | 'error';
  lastSyncAt?: Date;
}
```

### Configuration Types

#### Trace Configuration
```typescript
interface TraceConfig {
  sampling: {
    rate: number;
    rules: SamplingRule[];
  };
  routing: {
    rules: RoutingRule[];
    defaultDestination: string;
  };
  privacy: {
    piiDetection: boolean;
    redactionMethod: 'hash' | 'mask' | 'remove';
    customPatterns: PIIPattern[];
  };
  performance: {
    maxBatchSize: number;
    exportIntervalMs: number;
    compression: boolean;
  };
}
```

#### Integration Configuration
```typescript
interface IntegrationConfig {
  platform: string;
  credentials: Record<string, string>;
  settings: {
    batchSize?: number;
    timeout?: number;
    retryAttempts?: number;
  };
  filters?: {
    models?: string[];
    environments?: string[];
    tags?: string[];
  };
}
```

## Component Architecture

### API Server

The API server handles:
- Trace reception and validation
- Routing rule evaluation
- Integration delivery
- Authentication and authorization
- Team management
- Real-time analytics

### SDK Libraries

The SDK libraries provide:
- Automatic LLM instrumentation
- Trace capture and batching
- Local configuration management
- Error handling and retries
- Performance optimization

### Dashboard

The web dashboard provides:
- Real-time trace monitoring
- Routing configuration
- Integration management
- Analytics and insights
- Team collaboration

## Security Model

1. **API Authentication**
   - API keys for trace ingestion
   - JWT tokens for dashboard access
   - Role-based access control

2. **Data Privacy**
   - Automatic PII detection and redaction
   - Configurable data retention policies
   - Field-level encryption

3. **Team Access**
   - Organization-based isolation
   - Member role management
   - Shared trace visibility

## Scaling Considerations

1. **Database**
   - Trace archival and compression
   - Real-time analytics indexing
   - Connection pooling

2. **API Layer**
   - Request rate limiting
   - Load balancing
   - Regional distribution

3. **Trace Processing**
   - Batch processing for high volume
   - Retry mechanisms for failed deliveries
   - Queue management for routing

## Development Setup

For local development:

1. **Database**
```bash
# Start Postgres
docker compose up db
```

2. **API Server**
```bash
# Start API server
npm run dev:api
```

3. **SDK Development**
```bash
# Build and test SDKs
npm run build:sdks
npm run test:sdks
```

## Best Practices

1. **Trace Handling**
   - Implement proper retry logic
   - Handle timeouts gracefully
   - Log relevant debugging info

2. **Security**
   - Rotate API keys regularly
   - Monitor failed attempts
   - Review access logs

3. **Team Workflow**
   - Use meaningful service names
   - Configure appropriate sampling rates
   - Set up monitoring alerts